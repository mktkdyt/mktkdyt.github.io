<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ASP.NET on mktkdyt</title>
    <link>https://mktkdyt.github.io/post/asp_dot_net/</link>
    <description>Recent content in ASP.NET on mktkdyt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 14 Jan 2021 17:24:23 +0900</lastBuildDate><atom:link href="https://mktkdyt.github.io/post/asp_dot_net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ajax の CSRF 対策</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/ajax%E3%81%AEcsrf%E5%AF%BE%E7%AD%96/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/ajax%E3%81%AEcsrf%E5%AF%BE%E7%AD%96/</guid>
      <description>Ajax の CSRF 対策 SPAで非同期通信を多用すると思います。その際に、非同期通信の場合のCSRF対策について調査ました。
通常の同期処理（ページ遷移）の場合 ASP.NET MVCではCSRF対策が超簡単です。
ViewのFormの中でRazorの@Html.AntiForgeryToken()を呼ぶだけでトークンを埋め込むことが出来ます。
トークンを検証するにはControllerでActionMethodの属性にValidationAntiForgeryTokneを指定するだけです。
View
@using (Html.BeginForm()){ @Html.AntiForgeryToken() // 略 } Controller
[ValidationAntiForgeryToken] [HttpPost] public ActionResult Create(ViewModel model){ // 略 } ところが、非同期処理（Ajax）の場合は少々工夫が必要になります。
非同期処理（Ajax）の場合 Razorでクッキーのトークンとフォームのトークンを発行する関数を作成します。
作成した関数を呼び、hidden値に設定し、POST時にヘッダに付加してリクエストを送信します。
View
&amp;lt;script&amp;gt; @functions{ public string GenerateRequestVerificationToken() { string cookieToken, formToken; AntiForgery.GetTokens(null, out cookieToken, out formToken); return cookieToken + &amp;#34;:&amp;#34; + formToken; } } &amp;lt;/script&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; id=&amp;#34;requestValificationToken&amp;#34; value=&amp;#34;@GenerateRequestValificationToken()&amp;#34; /&amp;gt; JS
$.ajax({ url: http://test/Create,  type: &amp;#34;POST&amp;#34;, dataType: &amp;#34;json&amp;#34;, data: { data: hoge }, headers: { &amp;#39;RequestVerificationToken&amp;#39;: $(&amp;#39;#requestVerificationToken&amp;#39;).</description>
    </item>
    
    <item>
      <title>ASP.NET のモジュールを Jenkins で発行する</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/asp.net%E3%81%AE%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92jenkins%E3%81%A7%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/asp.net%E3%81%AE%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92jenkins%E3%81%A7%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B/</guid>
      <description>ASP.NET のモジュールを Jenkins で発行する デプロイモジュールを発行するために
msbuild target.sln /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=targetStaging /p:PublishProfile=targetProfile をjenkinsのジョブに登録し、実行すると以下のエラーが発生。
C:\ProgramFiles (x86)\MSBuild\Microsoft\VisualStudio\v14.0\Web\Transform\Microsoft.Web.Publishing.AspNetCompileMerge.targets(132,5): error :  Can&amp;#39;t find the valid AspnetMergePath [C:\Jenkins\workspace\Common_Build\Apps\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal.csproj] なにこれ。VisualStudioで発行するときに見たこと無いぞ。 とりあえずコマンドにAspnetMergePathを明示すれば動くだろ。
msbuild target.sln /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=targetStaging /p:PublishProfile=targetProfile /p:AspnetMergePath=&amp;#34;C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\&amp;#34; よっしゃ実行だ！
MSBUILD : error MSB1008: 1 つのプロジェクトのみを指定できます。 なん。。だと。。。。動かない。。。
よくよく見ると
Path To MSBuild.exe: msbuild.exe Executing the command cmd.exe /C &amp;#34; msbuild.exe /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=DebugPajdis /p:PublishProfile=DebugPajdis &amp;#34;\p:AspnetMergePath=C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools&amp;#34;&amp;#34; Apps\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal.sln &amp;#34; &amp;amp;&amp;amp; exit %%ERRORLEVEL%%from C:\Jenkins\workspace\Common_Build [Common_Build] $ cmd.</description>
    </item>
    
    <item>
      <title>AutoMapper を導入する</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/automapper%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/automapper%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B/</guid>
      <description>AutoMapper を導入する AutoMapperって？ オブジェクトの詰め替えをしてくれるツール。 マッパーを使うことでオブジェクトの詰め替えをその都度記述する必要がなくなるのでコーディングの作業量を減らすことが出来ます。 また、オブジェクト間のプロパティの対応関係を局所化することが出来るので、修正箇所が限定されます。
AutoMapperの取得 NuGetからAutoMapperを取得
AutoMapperConfigの作成 using AutoMapper; using Terdis.MasterInfoManagement.Service.DataTransferObject; using Terdis.Map.Application.Web.Dto; namespace Terdis.Map.Application.Web { public class AutoMapperConfig { public static void RegisterAutoMappings() { Mapper.Initialize(cfg =&amp;gt; { cfg.CreateMap&amp;lt;MasterInfoDto, DocumentTypeDto&amp;gt;() .ForMember(d =&amp;gt; d.Id, o =&amp;gt; o.MapFrom(s =&amp;gt; s.Name)) .ForMember(d =&amp;gt; d.Title, o =&amp;gt; o.MapFrom(s =&amp;gt; s.Code)); }); } } } Global.asaxへの登録 namespace Terdis.Map.Application.Web { public class Global : HttpApplication { void Application_Start(object sender, EventArgs e) { AutoMapperConfig.RegisterAutoMappings(); } } } ServiceでMappingを行う using System.</description>
    </item>
    
  </channel>
</rss>
