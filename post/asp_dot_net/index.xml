<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ASP.NET on mktkdyt</title>
    <link>https://mktkdyt.github.io/post/asp_dot_net/</link>
    <description>Recent content in ASP.NET on mktkdyt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Thu, 14 Jan 2021 17:24:23 +0900</lastBuildDate><atom:link href="https://mktkdyt.github.io/post/asp_dot_net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ajax の CSRF 対策</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/ajax%E3%81%AEcsrf%E5%AF%BE%E7%AD%96/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/ajax%E3%81%AEcsrf%E5%AF%BE%E7%AD%96/</guid>
      <description>Ajax の CSRF 対策 SPAで非同期通信を多用すると思います。その際に、非同期通信の場合のCSRF対策について調査ました。
通常の同期処理（ページ遷移）の場合 ASP.NET MVCではCSRF対策が超簡単です。
ViewのFormの中でRazorの@Html.AntiForgeryToken()を呼ぶだけでトークンを埋め込むことが出来ます。
トークンを検証するにはControllerでActionMethodの属性にValidationAntiForgeryTokneを指定するだけです。
View
@using (Html.BeginForm()){ @Html.AntiForgeryToken() // 略 } Controller
[ValidationAntiForgeryToken] [HttpPost] public ActionResult Create(ViewModel model){ // 略 } ところが、非同期処理（Ajax）の場合は少々工夫が必要になります。
非同期処理（Ajax）の場合 Razorでクッキーのトークンとフォームのトークンを発行する関数を作成します。
作成した関数を呼び、hidden値に設定し、POST時にヘッダに付加してリクエストを送信します。
View
&amp;lt;script&amp;gt; @functions{ public string GenerateRequestVerificationToken() { string cookieToken, formToken; AntiForgery.GetTokens(null, out cookieToken, out formToken); return cookieToken + &amp;#34;:&amp;#34; + formToken; } } &amp;lt;/script&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; id=&amp;#34;requestValificationToken&amp;#34; value=&amp;#34;@GenerateRequestValificationToken()&amp;#34; /&amp;gt; JS
$.ajax({ url: http://test/Create,  type: &amp;#34;POST&amp;#34;, dataType: &amp;#34;json&amp;#34;, data: { data: hoge }, headers: { &amp;#39;RequestVerificationToken&amp;#39;: $(&amp;#39;#requestVerificationToken&amp;#39;).</description>
    </item>
    
    <item>
      <title>ASP.NET のモジュールを Jenkins で発行する</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/asp.net%E3%81%AE%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92jenkins%E3%81%A7%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/asp.net%E3%81%AE%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92jenkins%E3%81%A7%E7%99%BA%E8%A1%8C%E3%81%99%E3%82%8B/</guid>
      <description>ASP.NET のモジュールを Jenkins で発行する デプロイモジュールを発行するために
msbuild target.sln /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=targetStaging /p:PublishProfile=targetProfile をjenkinsのジョブに登録し、実行すると以下のエラーが発生。
C:\ProgramFiles (x86)\MSBuild\Microsoft\VisualStudio\v14.0\Web\Transform\Microsoft.Web.Publishing.AspNetCompileMerge.targets(132,5): error :  Can&amp;#39;t find the valid AspnetMergePath [C:\Jenkins\workspace\Common_Build\Apps\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal.csproj] なにこれ。VisualStudioで発行するときに見たこと無いぞ。 とりあえずコマンドにAspnetMergePathを明示すれば動くだろ。
msbuild target.sln /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=targetStaging /p:PublishProfile=targetProfile /p:AspnetMergePath=&amp;#34;C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\&amp;#34; よっしゃ実行だ！
MSBUILD : error MSB1008: 1 つのプロジェクトのみを指定できます。 なん。。だと。。。。動かない。。。
よくよく見ると
Path To MSBuild.exe: msbuild.exe Executing the command cmd.exe /C &amp;#34; msbuild.exe /p:VisualStudioVersion=14.0 /p:DeployOnBuild=true /p:Configuration=DebugPajdis /p:PublishProfile=DebugPajdis &amp;#34;\p:AspnetMergePath=C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools&amp;#34;&amp;#34; Apps\Pajdis.CommonAndPortal\Pajdis.CommonAndPortal.sln &amp;#34; &amp;amp;&amp;amp; exit %%ERRORLEVEL%%from C:\Jenkins\workspace\Common_Build [Common_Build] $ cmd.</description>
    </item>
    
    <item>
      <title>Bundle と Minify</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/bundle%E3%81%A8minify/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/bundle%E3%81%A8minify/</guid>
      <description>Bundle と Minify ASP.NET MVCではwebpack使わなくてもスクリプトをバンドルできます． 各画面にソースのパスを書くのは面倒なのでBundleConfigでまとめてみます．
Microsoft.AspNet.Web.Optimizationの取得 Microsoft.AspNet.Web.OptimizationをNuGetから取得します．
BundleConfigの作成 App_StartフォルダにBundleConfig.csを追加します．
using System.Web.Optimization; public class BundleConfig { public static void RegisterBundles(BundleCollection bundles) { bundles.Add(new ScriptBundle(&amp;#34;~/bundles/jquery&amp;#34;).Include( &amp;#34;~/Scripts/jquery-{version}.js&amp;#34;)); bundles.Add(new ScriptBundle(&amp;#34;~/scripts/hoge&amp;#34;).Include( &amp;#34;~/Scripts/Sample/hoge.js&amp;#34;, &amp;#34;~/Scripts/Sample/fuga.js&amp;#34;, &amp;#34;~/Scripts/Sample/piyo.js&amp;#34;)); } } BundleConfigをGlobal.asaxへ登録する Global.asax.csでBundleConfigを呼び出すようにします．
using System.Web.Optimization; public class Global : HttpApplication { void Application_Start(object sender, EventArgs e) { BundleConfig.RegisterBundles(BundleTable.Bundles); } } 画面からBundleを呼び出す あとは画面で呼び出すだけです．
@using System.Web.Optimization &amp;lt;head&amp;gt; @Scripts.Render(&amp;#34;~/bundles/jquery&amp;#34;) @Scripts.Render(&amp;#34;~/bundles/hoge&amp;#34;) &amp;lt;/head&amp;gt; 結果
&amp;lt;head&amp;gt; &amp;lt;script src=&amp;#34;/map/scripts/jquery?v=WvOgJns1M1ZZkySVvxnR5qZTgNQ_UWnAsm21lcWbuMs1&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;#34;/map/scripts/hoge?v=fsiac-cyztW0v5rUgi-a9vvPTsOHXerrhW6x3w1IiHw1&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; ソースのパスをBundleConfigにまとめることが出来ました． また、BundleConfigで{version}と指定することでライブラリのバージョンを更新しても気にする必要がなくなりました． 更に、結果のソースを見てみるとminifyされていることが分かります．
var hoge=function(){function n(){}return n.</description>
    </item>
    
    <item>
      <title>面倒なオブジェクトマッピングは AutoMapper にやらせよう</title>
      <link>https://mktkdyt.github.io/post/asp_dot_net/%E9%9D%A2%E5%80%92%E3%81%AA%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AFautomapper%E3%81%AB%E3%82%84%E3%82%89%E3%81%9B%E3%82%88%E3%81%86/</link>
      <pubDate>Thu, 14 Jan 2021 17:24:23 +0900</pubDate>
      
      <guid>https://mktkdyt.github.io/post/asp_dot_net/%E9%9D%A2%E5%80%92%E3%81%AA%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AFautomapper%E3%81%AB%E3%82%84%E3%82%89%E3%81%9B%E3%82%88%E3%81%86/</guid>
      <description>面倒なオブジェクトマッピングは AutoMapper にやらせよう AutoMapperって？ オブジェクトの詰め替えをしてくれる.NETのライブラリです． マッパーを使うことでオブジェクトの詰め替えをその都度記述する必要がなくなるのでコーディング量を減らすことが出来ます． また、オブジェクト間のプロパティの対応関係を局所化することが出来るので、修正箇所が限定されます．
AutoMapperの取得 NuGetからAutoMapperを取得してください．
AutoMapperを使わない場合 MVCではよくEntityをViewModelに詰め替えることがあるかと思います． 例えばDBから取得したユーザをViewModelに詰め替えて返す場合こんな感じになるかと思います．
public class UserController { public ActionResult Detail(string name) { // DBからUSERを取得したとする  var user = Service.FindUserByName(name); // USER -&amp;gt; UserViewModel  var viewModel = new UserViewModel() { UserId = user.USER_ID; UserName = user.USER_NAME; Tel = user.TEL; Mail = user.MAIL; } return View(viewModel); } } Entity
public class USER { public string USER_ID { get; set; } public string USER_NAME { get; set; } public string TEL { get; set; } public string MAIL { get; set; } } ViewModel</description>
    </item>
    
  </channel>
</rss>
